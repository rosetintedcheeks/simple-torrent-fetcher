#!/usr/bin/python3
import os
import re
import sys
from datetime import datetime

import feedparser
import libtorrent
import requests
import yaml

# unsafe loader doesn't matter probably
# TODO: probably should fix this
yaml.warnings({'YAMLLoadWarning': False})

url = ""
watch_dir = ""
link_dir = ""
home = ""
show_dir = ""

regex_root = ""

line_num = 0
shows = []
auto = False
configfile = "scheduler.yaml"
config_base = "config_files"
verbose = False

configfile = config_base + "/" + configfile

os.chdir(os.path.dirname(os.path.abspath(__file__)))

for k, v in enumerate(sys.argv):
    if v == "-a":
        auto = True
    if v == "--config":
        configfile = config_base + "/" + sys.argv[k + 1]
    if v == "-h":
        print("--config [config_file]")
        exit()
    if v == "-v":
        verbose = True

with open(home + configfile, "r") as cf:
    i = False
    for doc in yaml.load_all(cf.read(), Loader=yaml.Loader):
        if not i:
            i = True
            url = doc['url']
            watch_dir = doc['watchdir']
            link_dir = doc['linkeddir']
        else:
            shows.append(doc)

print(shows)
feed_request = requests.get(url)
feed_text = feed_request.text
feed = feedparser.parse(feed_text)
linklist = []
for show in shows:
    matched = open(home + "matched.txt", "r")
    for match in matched:
        if match == (show['regex'] + "\n"):
            show['regex'] = ""
    matched.close()
    if show['regex'] != "":
        showre = re.compile(show['regex'])
        for item in feed.entries:
            match = showre.fullmatch(item["title"])
            if match is not None:
                try:
                    torrent_url = item.enclosures[0]['href']
                except IndexError:  # Try this if we fail TODO: make a function out of this or something
                    torrent_url = item.link
                req = requests.get(torrent_url)
                if verbose:
                    print("link from rss feed: " + torrent_url)
                tname = home + watch_dir + "/" + item["title"] + ".torrent"
                if verbose:
                    print("name of downloaded torrent: " + tname)
                torr = open(tname, "wb")
                torrbytes = bytearray(req.content)
                torr.write(torrbytes)  # Write torrent
                torr.close()
                fname = libtorrent.torrent_info(tname).files().file_name(0)  # Get name of file
                if verbose:
                    print("name of the file in the torrent:" + fname)
                fpath = show_dir + fname  # Path of file
                if 'sname' in show:
                    ldir = link_dir + '/' + show['sname']  # File will be linked in here
                    if not os.path.isdir(ldir):
                        os.mkdir(ldir)
                    # TODO: get rid of this and do it in another file
                    if 'change' in show and show['change'] != "false":
                        if 'nindex' in show:  # Horrible last resort, could use item title instead
                            enum = int(fname[int(show['nindex'][0]):int(show['nindex'][1])])
                            if 'nsubtract' in show:
                                enum -= int(show['nsubtract'])
                            fname = 's' + show['season'] + 'e' + str(enum) + '.mkv'  # :)

                    link_target = ldir + '/' + fname
                    if verbose:
                        print("symlink path: " + fpath)
                        print("symlink target: " + link_target)
                    try:
                        os.symlink(fpath, link_target)
                    except FileExistsError:
                        pass
                matched = open(home + "matched.txt", "a")
                matched.write(show['regex'] + "\n")
                matched.close()
                log = open(home + "scheduler.log", "a")
                try:
                    log_title = item["title"][int(show['tindex'][0]):int(show['tindex'][1])]
                except ValueError:
                    log_title = item["title"][int(show['tindex'][0]):]
                log_time = datetime.now()
                log_line = log_time.strftime("%x %X") + ": " + log_title + "\n"
                if not auto:
                    log_line = "M " + log_line
                log.write(log_line)
                log.close()
